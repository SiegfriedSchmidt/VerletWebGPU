!function(){"use strict";var r,i,e,t,s={303:function(r,i,e){e.a(r,(async function(r,i){try{var t=e(189);const r={renderTime:document.getElementById("renderTime")},s=document.getElementById("root"),n=new t.Z(s,r);await n.init()?n.update():document.body.innerHTML='<div class="not-supported"><h1>WebGPU not supported!</h1></div>',i()}catch(r){i(r)}}),1)},189:function(r,i,e){e.d(i,{Z:function(){return s}});function t(r,i,e){e/=100;const t=i=>(i+r/30)%12,s=(i/=100)*Math.min(e,1-e),n=r=>e-s*Math.max(-1,Math.min(t(r)-3,Math.min(9-t(r),1)));return[n(0),n(8),n(4)]}var s=class{constructor(r,i){this.canvas=r,this.info=i,this.resolution=[r.width,r.height],this.circleMaxCount=8e4,this.circleCurrentCount=1,this.deltaTime=.004,this.circleMaximumRadius=3,this.circleParams=12,this.gridCellParams=10,this.step=0,this.workgroupSize=8,this.gridResolution=[Math.ceil(this.resolution[0]/(2*this.circleMaximumRadius)),Math.ceil(this.resolution[1]/(2*this.circleMaximumRadius)),this.gridCellParams],this.workgroupSolveCollisionsCount=[Math.ceil(this.gridResolution[0]/this.workgroupSize),Math.ceil(this.gridResolution[1]/this.workgroupSize)]}async update(){for(let r=0;r<4;r++){const r=this.device.createCommandEncoder();this.step++,this.timeArray[0]=this.step,this.writeBuffer(this.timeBuffer,this.timeArray),this.circleCurrentCount=Math.min(this.circleMaxCount,6e3*Math.round(this.step*this.deltaTime*8)),this.globalParamsArray[0]=this.circleCurrentCount,this.writeBuffer(this.globalParamsBuffer,this.globalParamsArray),await this.solveCollisions(r),this.updateCircles(r),this.queue.submit([r.finish()])}const r=this.device.createCommandEncoder();this.render(r),this.queue.submit([r.finish()]),requestAnimationFrame((()=>this.update()))}async getCirclesBuffer(r){const i=this.circlesArray.byteLength;r.copyBufferToBuffer(this.circlesBuffer,0,this.stageBuffer,0,i),await this.stageBuffer.mapAsync(GPUMapMode.READ,0,i);const e=this.stageBuffer.getMappedRange(0,i).slice(0);this.stageBuffer.unmap(),this.circlesArray=new Float32Array(e)}getGridPos(r,i){return(Math.floor(r/(this.resolution[0]/this.gridResolution[0]))+Math.floor(i/(this.resolution[1]/this.gridResolution[1]))*this.gridResolution[0])*this.gridResolution[2]}fillGrid(){for(let r=0;r<this.circleCurrentCount;r++){const i=r*this.circleParams,e=this.getGridPos(this.circlesArray[i],this.circlesArray[i+1]);let t=2;this.gridArray[e]==this.step?t=this.gridArray[e+1]:this.gridArray[e]=this.step,this.gridArray[e+t]=r,this.gridArray[e+1]=t+1}}updateCircles(r){const i=r.beginComputePass();i.setPipeline(this.updateCirclesPipeline),i.setBindGroup(0,this.bindGroupCompute),i.dispatchWorkgroups(Math.ceil(this.circleCurrentCount/(this.workgroupSize*this.workgroupSize))),i.end()}async solveCollisions(r){await this.getCirclesBuffer(r),this.fillGrid(),this.writeBuffer(this.gridBuffer,this.gridArray);const i=r.beginComputePass();i.setPipeline(this.solveCollisionsPipeline),i.setBindGroup(0,this.bindGroupCompute),i.dispatchWorkgroups(this.workgroupSolveCollisionsCount[0],this.workgroupSolveCollisionsCount[1]),i.end()}render(r){const i=r.beginRenderPass({colorAttachments:[{view:this.context.getCurrentTexture().createView(),loadOp:"clear",clearValue:{r:0,g:0,b:0,a:1},storeOp:"store"}]});i.setPipeline(this.renderPipeline),i.setBindGroup(0,this.bindGroupRender),i.setVertexBuffer(0,this.vertexBuffer),i.draw(this.vertexArray.length/2,this.circleCurrentCount),i.end()}initCircles(){for(let r=0;r<this.circleMaxCount;r++){const i=r*this.circleParams;this.circlesArray[i]=10*r%this.resolution[0]+10,this.circlesArray[i+1]=this.resolution[1]-10*Math.floor(r/(this.resolution[0]/10))-20;this.circlesArray[i+2]=this.circlesArray[i],this.circlesArray[i+3]=this.circlesArray[i+1],this.circlesArray[i+4]=0,this.circlesArray[i+5]=-1e3,this.circlesArray[i+6]=0,this.circlesArray[i+7]=0;const e=t(r*(360/this.circleMaxCount),100,50);this.circlesArray[i+8]=e[0],this.circlesArray[i+9]=e[1],this.circlesArray[i+10]=e[2],this.circlesArray[i+11]=this.circleMaximumRadius}}async init(){return!!await this.initApi()&&(console.log(this.resolution,this.circleMaxCount),this.initCanvas(),this.createArrays(),this.createBuffers(),this.writeBuffers(),this.createLayouts(),this.createBindings(),this.createPipelines(),!0)}createArrays(){this.vertexArray=new Float32Array([-1,-1,1,-1,1,1,-1,-1,1,1,-1,1]),this.timeArray=new Int32Array([0]),this.resolutionArray=new Float32Array(this.resolution),this.gridResolutionArray=new Int32Array(this.gridResolution),this.gridArray=new Int32Array(this.gridResolutionArray[0]*this.gridResolutionArray[1]*this.gridCellParams),this.circlesArray=new Float32Array(this.circleMaxCount*this.circleParams),this.globalParamsArray=new Float32Array([this.circleMaxCount,this.deltaTime]),this.initCircles()}createBuffers(){this.vertexBuffer=this.createBuffer("vertices",this.vertexArray,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_DST),this.resolutionBuffer=this.createBuffer("resolution",this.resolutionArray,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),this.timeBuffer=this.createBuffer("time",this.timeArray,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),this.gridResolutionBuffer=this.createBuffer("grid resolution",this.gridResolutionArray,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),this.globalParamsBuffer=this.createBuffer("global params",this.globalParamsArray,GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST),this.circlesBuffer=this.createBuffer("circles",this.circlesArray,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC),this.stageBuffer=this.createBuffer("stage",this.circlesArray,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.gridBuffer=this.createBuffer("grid",this.gridArray,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST)}writeBuffers(){this.writeBuffer(this.vertexBuffer,this.vertexArray),this.writeBuffer(this.timeBuffer,this.timeArray),this.writeBuffer(this.resolutionBuffer,this.resolutionArray),this.writeBuffer(this.gridResolutionBuffer,this.gridResolutionArray),this.writeBuffer(this.circlesBuffer,this.circlesArray),this.writeBuffer(this.globalParamsBuffer,this.globalParamsArray)}createLayouts(){this.vertexBufferLayout=this.createVertexLayout(2*this.vertexArray.BYTES_PER_ELEMENT,"float32x2"),this.bindGroupComputeLayout=this.device.createBindGroupLayout({label:"bind group compute layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]}),this.pipelineComputeLayout=this.device.createPipelineLayout({label:"compute pipeline layout",bindGroupLayouts:[this.bindGroupComputeLayout]}),this.bindGroupRenderLayout=this.device.createBindGroupLayout({label:"bind group render layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:2,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),this.pipelineRenderLayout=this.device.createPipelineLayout({label:"render pipeline layout",bindGroupLayouts:[this.bindGroupRenderLayout]})}createBindings(){this.bindGroupCompute=this.device.createBindGroup({label:"Bind group compute",layout:this.bindGroupComputeLayout,entries:[{binding:0,resource:{buffer:this.resolutionBuffer}},{binding:1,resource:{buffer:this.timeBuffer}},{binding:2,resource:{buffer:this.gridResolutionBuffer}},{binding:3,resource:{buffer:this.globalParamsBuffer}},{binding:4,resource:{buffer:this.circlesBuffer}},{binding:5,resource:{buffer:this.gridBuffer}}]}),this.bindGroupRender=this.device.createBindGroup({label:"Bind group compute",layout:this.bindGroupRenderLayout,entries:[{binding:0,resource:{buffer:this.circlesBuffer}},{binding:1,resource:{buffer:this.resolutionBuffer}},{binding:2,resource:{buffer:this.globalParamsBuffer}}]})}createPipelines(){const r=this.device.createShaderModule({code:"struct Circle {\r\n    pos: vec2f,\r\n    last_pos: vec2f,\r\n    accel: vec2f,\r\n    color: vec3f,\r\n    radius: f32\r\n}\r\n\r\n@group(0) @binding(0) var<storage> circle: array<Circle>;\r\n@group(0) @binding(1) var<uniform> res: vec2f;\r\n\r\n@fragment\r\nfn main(@builtin(position) pos: vec4f, @location(0) @interpolate(flat) id: u32) -> @location(0) vec4f {\r\n    let pos2 = vec2f(pos.x, res.y - pos.y);\r\n    let dis = length(pos2 - circle[id].pos);\r\n//    if (dis > circle[id].radius) {\r\n//        discard;\r\n//    }\r\n    var color = circle[id].color;\r\n//    color *= (1 - 1 / (circle[id].radius - dis));\r\n    return vec4f(color, 1);\r\n}\r\n"}),i=this.device.createShaderModule({code:"struct Circle {\r\n    pos: vec2f,\r\n    last_pos: vec2f,\r\n    accel: vec2f,\r\n    color: vec3f,\r\n    radius: f32\r\n}\r\n\r\nstruct VertexOutput {\r\n    @builtin(position) pos: vec4f,\r\n    @location(0) @interpolate(flat) id: u32\r\n}\r\n\r\n@group(0) @binding(0) var<storage> circle: array<Circle>;\r\n@group(0) @binding(1) var<uniform> res: vec2f;\r\n\r\n@vertex\r\nfn main(@location(0) pos: vec2f, @builtin(instance_index) id: u32) -> VertexOutput {\r\n    let offset = circle[id].pos / vec2f(res) * 2 - 1;\r\n    return VertexOutput(vec4f(pos / (res / circle[id].radius) * 2 + offset, 0, 1), id);\r\n}"}),e=this.device.createShaderModule({code:"const PI = 3.14159265359;\r\n\r\nstruct Circle {\r\n    pos: vec2f,\r\n    lpos: vec2f,\r\n    accel: vec2f,\r\n    color: vec3f,\r\n    radius: f32\r\n}\r\n\r\nstruct Global {\r\n    circleCount: f32,\r\n    dt: f32,\r\n}\r\n\r\n@group(0) @binding(0) var<uniform> res: vec2f;\r\n@group(0) @binding(1) var<uniform> time: i32;\r\n@group(0) @binding(2) var<uniform> grid_res: vec3i;\r\n@group(0) @binding(3) var<uniform> global: Global;\r\n@group(0) @binding(4) var<storage, read_write> circle: array<Circle>;\r\n@group(0) @binding(5) var<storage, read_write> grid: array<i32>;\r\n\r\nfn hash(state: f32) -> f32 {\r\n    var s = u32(state);\r\n    s ^= 2747636419;\r\n    s *= 2654435769;\r\n    s ^= s >> 16;\r\n    s *= 2654435769;\r\n    s ^= s >> 16;\r\n    s *= 2654435769;\r\n    return f32(s) / 4294967295;\r\n}\r\n\r\nfn apply_constaint(i: u32) {\r\n    if (circle[i].pos.y > res.y - circle[i].radius) {\r\n        circle[i].pos.y = res.y - circle[i].radius;\r\n    }\r\n    if (circle[i].pos.y < circle[i].radius) {\r\n        circle[i].pos.y = circle[i].radius;\r\n    }\r\n    if (circle[i].pos.x > res.x - circle[i].radius) {\r\n        circle[i].pos.x = res.x - circle[i].radius;\r\n    }\r\n    if (circle[i].pos.x < circle[i].radius) {\r\n        circle[i].pos.x = circle[i].radius;\r\n    }\r\n}\r\n\r\nfn get_cell(pos: vec2f) -> vec2i {\r\n    return vec2i(floor(pos / (res / vec2f(grid_res.xy))));\r\n}\r\n\r\nfn get_pos(pos: vec2i) -> i32 {\r\n    return (pos.x + pos.y * grid_res.x) * grid_res.z;\r\n}\r\n\r\nfn write_grid(i: u32) {\r\n    let grid_pos = get_pos(get_cell(circle[i].pos));\r\n    var grid_i = 2;\r\n    if (grid[grid_pos] == time) {\r\n        grid_i = grid[grid_pos + 1];\r\n    } else {\r\n        grid[grid_pos] = time;\r\n    }\r\n    grid[grid_pos + grid_i] = i32(i);\r\n    grid[grid_pos + 1] = grid_i + 1;\r\n}\r\n\r\nfn solve_collision(i1: i32, i2: i32) {\r\n    let collision_axis = circle[i1].pos - circle[i2].pos;\r\n    let dist = length(collision_axis);\r\n    let min_dist = circle[i1].radius + circle[i2].radius;\r\n    if (dist < min_dist) {\r\n        let v = collision_axis / dist;\r\n        let delta_v = v * ((min_dist - dist) * 0.5);\r\n        circle[i1].pos += delta_v;\r\n        circle[i2].pos -= delta_v;\r\n    }\r\n}\r\n\r\n@compute @workgroup_size(64)\r\nfn update_circles(@builtin(global_invocation_id) id: vec3u) {\r\n    if (id.x >= u32(global.circleCount)) {\r\n        return;\r\n    }\r\n    let i = id.x;\r\n\r\n    apply_constaint(i);\r\n    let displacement = circle[i].pos - circle[i].lpos;\r\n    circle[i].lpos = circle[i].pos;\r\n    circle[i].accel = (res / 2) - circle[i].pos;\r\n    let len = max(1, length(circle[i].accel));\r\n    circle[i].accel = circle[i].accel / (len * len) * 50000;\r\n    circle[i].pos += displacement + circle[i].accel * global.dt * global.dt;\r\n//    write_grid(i);\r\n}\r\n\r\n@compute @workgroup_size(8, 8)\r\nfn find_collisions(@builtin(global_invocation_id) workgroup_pos: vec3u) {\r\n    let pos = vec2i(workgroup_pos.xy);\r\n    if (pos.x >= grid_res.x || pos.y >= grid_res.y) {\r\n        return;\r\n    }\r\n\r\n    let grid_pos1 = get_pos(pos.xy);\r\n    if (grid[grid_pos1] == time) {\r\n        let x_left = max(0, pos.x - 1);\r\n        let x_right = min(grid_res.x - 1, pos.x + 1);\r\n        let y_left = max(0, pos.y - 1);\r\n        let y_right = min(grid_res.y - 1, pos.y + 1);\r\n\r\n        for (var x = x_left; x <= x_right; x++) {\r\n            for (var y = y_left; y <= y_right; y++) {\r\n                let grid_pos2 = get_pos(vec2i(x, y));\r\n                if (grid[grid_pos2] == time) {\r\n                    let c1 = grid[grid_pos1 + 1];\r\n                    let c2 = grid[grid_pos2 + 1];\r\n                    for (var i1 = 2; i1 < c1; i1++) {\r\n                        for (var i2 = 2; i2 < c2; i2++) {\r\n                            let id_1 = grid[grid_pos1 + i1];\r\n                            let id_2 = grid[grid_pos2 + i2];\r\n                            if (id_1 != id_2) {\r\n                                solve_collision(id_1, id_2);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n"});this.updateCirclesPipeline=this.device.createComputePipeline({label:"update circles pipeline",layout:this.pipelineComputeLayout,compute:{module:e,entryPoint:"update_circles"}}),this.solveCollisionsPipeline=this.device.createComputePipeline({label:"solve collisions pipeline",layout:this.pipelineComputeLayout,compute:{module:e,entryPoint:"find_collisions"}}),this.renderPipeline=this.device.createRenderPipeline({label:"render pipeline",layout:this.pipelineRenderLayout,vertex:{module:i,entryPoint:"main",buffers:[this.vertexBufferLayout]},fragment:{module:r,entryPoint:"main",targets:[{format:this.canvasFormat}]}})}async initApi(){try{this.adapter=await navigator.gpu.requestAdapter(),this.device=await this.adapter.requestDevice(),this.queue=this.device.queue,console.log("Adapter: ",this.adapter),console.log("Device: ",this.device)}catch(r){return console.log(r),!1}return!0}initCanvas(){this.context=this.canvas.getContext("webgpu"),this.canvasFormat=navigator.gpu.getPreferredCanvasFormat(),this.context.configure({device:this.device,format:this.canvasFormat})}createBuffer(r,i,e){return this.device.createBuffer({label:r,size:i.byteLength,usage:e})}writeBuffer(r,i){this.queue.writeBuffer(r,0,i)}createVertexLayout(r,i){return{arrayStride:r,attributes:[{format:i,offset:0,shaderLocation:0}]}}}}},n={};function o(r){var i=n[r];if(void 0!==i)return i.exports;var e=n[r]={exports:{}};return s[r](e,e.exports,o),e.exports}r="function"==typeof Symbol?Symbol("webpack queues"):"__webpack_queues__",i="function"==typeof Symbol?Symbol("webpack exports"):"__webpack_exports__",e="function"==typeof Symbol?Symbol("webpack error"):"__webpack_error__",t=function(r){r&&!r.d&&(r.d=1,r.forEach((function(r){r.r--})),r.forEach((function(r){r.r--?r.r++:r()})))},o.a=function(s,n,o){var a;o&&((a=[]).d=1);var c,u,l,f=new Set,d=s.exports,h=new Promise((function(r,i){l=i,u=r}));h[i]=d,h[r]=function(r){a&&r(a),f.forEach(r),h.catch((function(){}))},s.exports=h,n((function(s){var n;c=function(s){return s.map((function(s){if(null!==s&&"object"==typeof s){if(s[r])return s;if(s.then){var n=[];n.d=0,s.then((function(r){o[i]=r,t(n)}),(function(r){o[e]=r,t(n)}));var o={};return o[r]=function(r){r(n)},o}}var a={};return a[r]=function(){},a[i]=s,a}))}(s);var o=function(){return c.map((function(r){if(r[e])throw r[e];return r[i]}))},u=new Promise((function(i){(n=function(){i(o)}).r=0;var e=function(r){r!==a&&!f.has(r)&&(f.add(r),r&&!r.d&&(n.r++,r.push(n)))};c.map((function(i){i[r](e)}))}));return n.r?u:o()}),(function(r){r?l(h[e]=r):u(d),t(a)})),a&&(a.d=0)},o.d=function(r,i){for(var e in i)o.o(i,e)&&!o.o(r,e)&&Object.defineProperty(r,e,{enumerable:!0,get:i[e]})},o.o=function(r,i){return Object.prototype.hasOwnProperty.call(r,i)};o(303)}();